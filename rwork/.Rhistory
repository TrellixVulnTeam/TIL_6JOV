eruptions.long<-faithful %>%  filter(eruptions>3)
head(eruptions.long)
points(eruptions.long,col='red',pch=19)
#dev.off()
dev.off()
#선형회귀모델
#분출시간에 따라 대시시간의 변화가 어떠한지
faithful.lm<-lm(waiting ~ eruptions,data=faithful)
faithful.lm
#fitted: 회귀모델에서 예측값 추출
plot(faithful)
points(eruptions.long,col='red',pch=19)
fitted(faithful.lm<)
fitted(faithful.lm)
head(fitted(faithful.lm))
lines(x=faithful$eruptions, y=fitted(faithful.lm),col='blue')
abline(v=3,col='purple')
abline(h=mean(faithful$waiting), col='green')
faithful.lm
coef(faithful.lm[1])
abline(a=faithful.lm[1], coef(faithful.lm[2]))
abline(a=coef(faithful.lm[1]), b=coef(faithful.lm[2]))
cars
str(cars)
cars$speed
cars$disp
cars$dist
cars$disp
plot(cars$speed, cars$dist)
cars$speed
cars$disp
#plot(x) :x타입에 따라 출력되는 그래프가 달라짐.
#x: 벡터, 데이터프레임, 팩터, 시계열, 테이블, 선형회귀모델...
cars
str(ToothGrowth)
plot(ToothGrowth$supp, ToothGrowth$len)
str(iris)
plot(iris[,1:4])
nhtemp
str(nhtemp)
plot(ngtemp)
plot(nhtemp)
UCBAdmissions
str(UCBAdmissions)
plot(UCBAdmissions)
pnf('myplot.png')
png('myplot.png')
png('myplot.png',width=800, height=400)
plot(faithful)
dev.off()
windows()
savePlot('myplot.pdf',type='pdf')
savePlot('myplot.pdf',type='png')
window()
savePlot('myplot.pdf',type='pdf')
savePlot('myplot.png',type='png')
#저장
png('myplot.png',width=800, height=400)
plot(faithful)
dev.off()
#머신러닝-> knn 알고리즘을 이용한 암 분류기 제작
wbcd<-read.csv('wisc_bc_data.csv')
str(wbcd)
wbcd<-wbcd[-1]
str(wbcd)
table(wbcd$diagnosis)
factor(wbcd$diagnosis, levels = c("B","M"), labels = c("Benign",'Malignant'))
wbcd$diagnosis<-factor(wbcd$diagnosis, levels = c("B","M"), labels = c("Benign",'Malignant'))
str(wbcd)
table(wbcd$diagnosis)
round(prop.table(table(wbcd$diagnosis))*100,1)
wbcd['radius_mean']
summary(wbcd['radius_mean'])
summary(wbcd['radius_mean','area_mean','smoothness_mean'])
summary(wbcd[c('radius_mean','area_mean','smoothness_mean')])
normalize<- function(x){
((x-min(x))/(max(x)-min(x)))
}
normalize(c(10,20,30,40,50,))
normalize(c(10,20,30,40,50))
str(wbcs)
str(wbcd)
wbcd[2:31]
lapply(wbcd[2:31], normalize)
wbcd_n<-as.data.frame(lapply(wbcd[2:31], normalize))
wbcd_n
wbcd_n[1:469,]
wbcd_train<-wbcd_n[1:469,]
wbcd_test<-wbcd_n[470:569,]
wbcd_train_labels<-wbcd[1:469,1]
wbcd_test_labels<-wbcd[470:569,1]
library(class)
#모델 생성
#주변에 있는 가까운 21개의 데이터를 검색하고 그 데이터를 다수결로 해서 판단.
library(class)
wbcd_test_pred<-knn(train=wbcd_train, test=wbcd_test,
cl=wbcd_train_labels, k=21)
wbcd_test_pred
#cross table
library(gmodels)
#cross table
library(gmodels)
crossTable(x=wbcd_test_labels, y - wbcd_test_pred)
#cross table
library(gmodels)
#cross table
library(gmodels)
#표준화
wbcd[-1]
#표준화
scale(wbcd[-1])
#표준화
as.data.frame(scale(wbcd[-1]))
#표준화
wbcd_z<-as.data.frame(scale(wbcd[-1]))
summary(wbcd_z$area_mean)
wbcd_train<-wbcd_z[1:469,]
wbcd_test<-wbcd_z[470:569,]
wbcd_test_pred<-knn(train=wbcd_train, test=wbcd_test,
cl=wbcd_train_labels, k=21)
library(gmodels)
install.packages(c("gmodels"))
library(gmodels)
library(gmodels)
CrossTable(x=wbcd_test_labels, y=wbcd_test_pred)
#퀴즈2
wbcd_test_pred<-knn(train=wbcd_train, test=wbcd_test,
cl=wbcd_train_labels, k=for(i in 21)
i=i+2
)
#퀴즈2
wbcd_test_pred<-knn(train=wbcd_train, test=wbcd_test,
cl=wbcd_train_labels, k=for(i in 21)
i=i+2
print(i)
)
#퀴즈2
wbcd_test_pred<-knn(train=wbcd_train, test=wbcd_test,
cl=wbcd_train_labels, k=for(i in seq(1,25,2))
)
#퀴즈2
wbcd_test_pred<-knn(train=wbcd_train, test=wbcd_test,
cl=wbcd_train_labels, k=for(i in seq(1,25,2))
)
#퀴즈2
wbcd_test_pred<-knn(train=wbcd_train, test=wbcd_test,
cl=wbcd_train_labels, k=for(i in seq(1,25,2)))
for(i in seq(1,25,2)){
wbcd_test_pred<-knn(train=wbcd_train, test=wbcd_test,
cl=wbcd_train_labels, k=i)
}
wbcd_test_labels
wbcd_z
wbcd
wbcd_test_pred<-knn(train=wbcd_train, test=wbcd_test,
cl=wbcd_train_labels, k=21)
wbcd_test_pred
CrossTable(x=wbcd_test_labels, y=wbcd_test_pred)
#or
for (i in seq(1, 25, 2)) {
wbcd_test_pred <- knn(train=wbcd_train, test=wbcd_test, cl=wbcd_train_labels, k=i)
print(paste(i, sum(wbcd_test_labels==wbcd_test_pred)/length(wbcd_test_pred)))
}
coef(faithful.lm[1])  #절편만 나옴
coef(faithful.lm[2]) #기울기만 나옴
abline(a=coef(faithful.lm[1]), b=coef(faithful.lm[2]))
plot(faithful)  #산점도
plot(faithful)  #산점도
faithful
plot(faithful)  #산점도
#faithful에서 분출시간이 3분 초과한 데이터 저장
library(dplyr)
eruptions.long<-faithful %>%  filter(eruptions>3)
head(eruptions.long)
#or
eruptions.long <- faithful[faithful$eruptions>3,]
#or
eruptions.long <- faithful %>% filter(eruptions>3)
#col-색상, pch-크기
points(eruptions.long,col='red',pch=19)
#dev.off()->그래프 없앰
dev.off()
#선형회귀모델
#분출시간에 따라 대시시간의 변화가 어떠한지
faithful.lm<-lm(waiting ~ eruptions,data=faithful)
#절편: 33.47 기울기: 10.73
faithful.lm
#fitted: 회귀모델에서 예측값 추출
plot(faithful)
points(eruptions.long,col='red',pch=19)
#waiting= 10.73 * x +33.47 (예측값)
fitted(faithful.lm) #예측값 추출
head(fitted(faithful.lm))
#회귀선
lines(x=faithful$eruptions, y=fitted(faithful.lm),col='blue')
#3이라는 값을 지나는 선 추가
abline(v=3,col='purple')
abline(h=mean(faithful$waiting), col='green')
coef(faithful.lm[1])  #절편만 나옴
coef(faithful.lm[2]) #기울기만 나옴
abline(a=coef(faithful.lm[1]), b=coef(faithful.lm[2]))
#plot(x) :x타입에 따라 출력되는 그래프가 달라짐.
#x: 벡터, 데이터프레임, 팩터, 시계열, 테이블, 선형회귀모델...
cars
str(cars)
cars$speed
cars$disp
#벡터이므로 산점도 그래프로 출력됨
plot(cars$speed, cars$dist)
str(ToothGrowth)
plot(ToothGrowth$supp, ToothGrowth$len)
str(iris)
#plot함수로 시각화할때 변수가 2개를 촐과하는 경우에는
#산점도 행렬로 생성
plot(iris[,1:4])
nhtemp
str(nhtemp)
plot(nhtemp)
UCBAdmissions
str(UCBAdmissions)
#머신러닝-> knn 알고리즘을 이용한 암 분류기 제작
wbcd<-read.csv('wisc_bc_data.csv')
str(wbcd)
wbcd<-wbcd[-1]
str(wbcd)
table(wbcd$diagnosis)
wbcd$diagnosis<-factor(wbcd$diagnosis, levels = c("B","M"), labels = c("Benign",'Malignant'))
str(wbcd)
prop.table(table(wbcd$diagnosis))
round(prop.table(table(wbcd$diagnosis))*100,1)
summary(wbcd[c('radius_mean','area_mean','smoothness_mean')])
normalize<- function(x){
((x-min(x))/(max(x)-min(x)))
}
normalize(c(10,20,30,40,50))
wbcd[2:31]
wbcd_n<-as.data.frame(lapply(wbcd[2:31], normalize))
wbcd_n
k_res <- c()
for (i in seq(from=1,to=25,by=2)){
wbcd_test_pred<-knn(train=wbcd_train,
test=wbcd_test,
cl=wbcd_train_labels,
k=i)
k_res <- c(k_res, sum(wbcd_test_labels==wbcd_test_pred))
}
best_k <- which.max(k_res)*2-1
best_k
wbcd_train<-wbcd_n[1:469,]
wbcd_test<-wbcd_n[470:569,]
wbcd_train_labels<-wbcd[1:469,1]
wbcd_test_labels<-wbcd[470:569,1]
library(class)
wbcd_test_pred<-knn(train=wbcd_train, test=wbcd_test,
cl=wbcd_train_labels, k=21)
wbcd_test_pred  #예측결과
#cross table
library(gmodels)
crossTable(x=wbcd_test_labels, y - wbcd_test_pred)
install.packages(c("gmodels"))
install.packages(c("gmodels"))
#cross table
library(gmodels)
crossTable(x=wbcd_test_labels, y - wbcd_test_pred)
CrossTable(x=wbcd_test_labels, y - wbcd_test_pred)
#cross table
library(gmodels)
CrossTable(x=wbcd_test_labels, y - wbcd_test_pred)
CrossTable(x=wbcd_test_labels, y=wbcd_test_pred)
CrossTable(x=wbcd_test_labels, y = wbcd_test_pred)
# 1. iris 데이터에 대해 knn 적용하여 분류 모델 작성
# -set.seed(1234)로 통일할 것
# -iris 데이터를 7:3의 비율로 나눈다(sample함수 적용)
# -트레인 데이터로 knn 모델 생성
# -테스트 데이터로 테스트(타깃 컬럼 : species)
data(iris)
str(iris)
set.seed(1234)
#표준화
iris_n<-as.data.frame(scale(iris[-5]))
# 1. iris 데이터에 대해 knn 적용하여 분류 모델 작성
# -set.seed(1234)로 통일할 것
# -iris 데이터를 7:3의 비율로 나눈다(sample함수 적용)
# -트레인 데이터로 knn 모델 생성
# -테스트 데이터로 테스트(타깃 컬럼 : species)
data(iris)
str(iris)
set.seed(1234)
#표준화
iris_n<-as.data.frame(scale(iris[-5]))
sample_idx<-sample(1:nrow(iris),nrow(iris)*0.2)
sample_idx
nrow(iris)
nrow(iris)*0.2
iris_train<-iris_n[-sample_idx,]
iris_test<-iris_n[sample_idx,]
head(iris)
train_labels<-iris[-sample_idx,5]
test_labels<-iris[sample_idx,5]
library(class)
scores<-c()
test_predict<-knn(train=iris_train,test = iris_test,
cl=train_labels,k=21)
test_predict
for(i in seq(1,25,2)){
test_predict<-knn(train=iris_train,test = iris_test,
cl=train_labels,k=i)
scores=c(scores,sum(test_predict==test_labels)/length(test_labels))
}
max(scores)
scores
max(scores)
seq(1,25,2)[which.max(scores)]
train<-read.csv('train.csv',na.string='')
test<-read.csv('test.csv',na.string='')
str(train)
str(test)
#결측치
#cabin, age, embarked, Fare 결측, cabin은 결측이 너무 많으니 버림
library(Amelia)
#상관관계 살펴보기
# 성별 수량변수로 변화
train$Sex<-ifelse(train$Sex=='female',1,0)
test$Sex<-ifelse(test$Sex=='female',1,0)
#결측값 예측
ggcorr(train,nbreaks=5,label = T) # Age<- Pclass,SibSp
library(ggplot2)
library(GGally)
#결측값 예측
ggcorr(train,nbreaks=5,label = T) # Age<- Pclass,SibSp
sum(is.na(train$Pclass))
sum(is.na(train$SibSp))
sum(is.na(train$Fare))
sum(is.na(test$Pclass))
sum(is.na(test$SibSp))
sum(is.na(test$Fare))
#test$Fare -> Pclass,성별 별 평균 fare로 대체
keys<-test[is.na(test$Fare),c('Pclass','Sex')]
keys
P<-keys[[1]]
p
S<-as.character(keys[[2]])
P
S<-as.character(keys[[2]])
S
as.data.frame(with(test,tapply(Fare,list(Pclass,Sex),mean,na.rm=T)))[P,S]
as.data.frame(with(test,tapply(Fare,list(Pclass,Sex),mean,na.rm=T)))
test$Fare
list(Pclass,Sex)
list(test$Pclass,test$Sex)
as.data.frame(with(test,tapply(Fare,list(Pclass,Sex),mean,na.rm=T)))
head(test$Fare)
test$Fare
as.data.frame(with(test,tapply(Fare,list(Pclass,Sex),mean,na.rm=T)))
as.data.frame(with(test,tapply(Fare,list(P=Pclass,S=Sex),mean,na.rm=T)))
as.data.frame(with(test,tapply(Fare,list(Pclass,Sex),mean,na.rm=T)))
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length,iris$Species,length)
str(iris)
#실린더(cyl)개수별 am 유형별 조합에 따른 mpg평균
#      a    m
#  4
#  6
#  8
with(car,tapply(mpg, list(cyl,am), mean))
car$cyl
as.data.frame(with(test,tapply(Fare,list(Pclass,Sex),mean,na.rm=T)))
head(test)
as.data.frame(with(test,tapply(Fare,list(Pclass,Sex),mean,na.rm=T)))[P,S]
P<-keys[[1]]
S<-as.character(keys[[2]])
P
S
#test$Fare -> Pclass,Sex 별 평균 fare로 대체
keys<-test[is.na(test$Fare),c('Pclass','Sex')]
keys
as.data.frame(with(test,tapply(Fare,list(Pclass,Sex),mean,na.rm=T)))
P<-keys[[1]]
keys
test$Fare[is.na(test$Fare)]<-as.data.frame(with(test,tapply(Fare,list(Pclass,Sex),mean,na.rm=T)))[P,S]
str(test)
#동승자 여부 범주화
train$family<-train$Parch+train$SibSp
test$family<-test$Parch+test$SibSp
train$family<-ifelse(train$family==0,0,1)
test$family<-test$Parch+test$SibSp
#Age=> 범주화 pclass,성별,fare별 평균
train$Age<-ifelse(train$Age<13,0,1)
test$Age<-ifelse(test$Age<13,0,1)
with(train,tapply(Age,list(Pclass,Sex,family),mean,na.rm=T))
head(test)
normalize<-function(x){
return((x-min(x,na.rm=T))/(max(x,na.rm=T)-min(x,na.rm=T)))
}
str(train)
train_n<-as.data.frame(sapply(train[c('Pclass','Sex','Age','Fare','family')],normalize))
test_n<-as.data.frame(sapply(test[c('Pclass','Sex','Age','Fare','family')],normalize))
str(test)
set.seed(1234)
set.seed(1234)
sum(is.na(test$Sex))
train_n
sum(is.na[test$Age])
sum(is.na[train$Age])
sum(is.na(train$Age)
sum(is.na(train$Age))
sum(is.na(train$Age))
sum(is.na(test$Age))
train_age_model=train_n[!is.na(train_n$Age),]
sample_idx<-sample(1:nrow(train_age_model),nrow(train_age_model)*0.2)
train_train_age=train_age_model[-sample_idx,-3]
train_age_model
head(train_age_model)
train_train_age=train_age_model[-sample_idx,-3]
train_test_age=train_age_model[sample_idx,-3]
train_age_label=train_age_model[-sample_idx,3]
test_age_label=train_age_model[sample_idx,3]
train_age_predict<-knn(train=train_train_age,test = train_test_age,
cl=train_age_label,k=5)
train_age_predict
set.seed(1234)
sample_idx<-sample(1:nrow(train),nrow(train)*0.2)
train_train<-newtrain[-sample_idx,]
newtrain
head(train)
train[-6]
head(train[-6])
head(train)
train <- read.csv('train.csv',na.strings = '')
test <- read.csv('test.csv',na.strings = '')
train$Sex
#Sex
train$Sex<- ifelse(train$Sex=='male',0,1)
train
#Embarked
sum(is.na(train$Embarked)) # 2
y<-table(train$Embarked)
y
names(y)
names(y)[which(y==max(y))]
train[is.na(train$Embarked),]$Embarked
train[is.na(train$Embarked),]$Embarked <-names(y)[which(y==max(y))]
train$Embarked[train$Embarked=='S']<-1
train$Embarked[train$Embarked=='C']<-2
train$Embarked[train$Embarked=='Q']<-3
head(train)
#Age
scaled <- data.frame(sapply(train[,c('Pclass', 'SibSp', 'Parch', 'Fare','Embarked','Sex')], as.numeric))
head(scaled)
scaled <-apply(scaled,2,function(x){(x-min(x,na.rm=T))/(max(x,na.rm=T)-min(x,na.rm=T))})
head(scaled)
age.naidx <-which(is.na(train$Age))
age.naidx
#cor함수: 상관계수 ->두 변수 사이에 상관성을 수치로, 하나의 변수의 값의 변화에 따라 다른 변수가 어떻게 변하는지 (+1~-1)
#절대값이 0.7정도 이상이면 강한 상관관계,
#Age열과 가장 상관관계가 높은 것
cor(scaled[-age.naidx,],train[-age.naidx,]$Age)
#Age결측값 대체
for (i in age.naidx){
eu.dis<-sqrt(colSums((t(scaled[,c('Pclass','SibSp','Parch')])-scaled[i,c('Pclass','SibSp','Parch')])^2))
top10.idx<-order(eu.dis)[1:10]
train$Age[i]<-mean(train[top10.idx,'Age'],na.rm=T)
}
sum(is.na(train$Age))
train<-read.csv("train.csv")
train
test<-read.csv("test.csv")
test
str(train)
names(train)
#4,9,11번 열 제외
train[, c(4,9,11)]
#4,9,11번 열 제외
train[,c(4,9,11)]
#4,9,11번 열 제외
train<-train[,-c(4,9,11)]
train
head(train)
source('~/.active-rstudio-document', echo=TRUE)
test<-test[,-c(3,8,10)]
names(test)
names(train)
class(train$Sex)
#성별 0,1로 변환
#Switch함수(ifelse문과 비슷)
x<-c(5,6,7,8)
switch(2,mean(x),sum(x),var(x))
switch(1,mean(x),sum(x),var(x))
sapply(train$Sex,switch, 'male'=0,'female'=1)
class(train$Sex`)
class(train$Sex)
class(train$Sex)
train$Sex<-sapply(train$Sex,switch, 'male'=0,'female'=1)
test$Sex<-sapply(test$Sex,switch, 'male'=0,'female'=1)
#승선 항구 c=0, Q=1, S=2로 변환
train$Embarked<-sapply(train$Embarked,switch, 'C'=0,'Q'=1,'S'=2)
test$Embarked<-sapply(test$Embarked,switch,'C'=0,'Q'=1,'S'=2)
#나이와 운임 열에 대해 na제거
na.omit(train$Age)
#나이와 운임 열에 대해 na제거
train$Age<-na.omit(train$Age)
#나이와 운임 열에 대해 na제거
train_age<-na.omit(train$Age)
train_age
#나이와 운임 열에 대해 na제거
train_age<-na.omit(train$Age)
train_age
train<-read.csv("train.csv")
train
test<-read.csv("test.csv")
test
train<-read.csv("train.csv")
