data.frame(car$mpg,car$am)
unstack(data.frame(car$mpg,car$am))
iris$Sepal.Length
unstack(data.frame(iris$Sepal.Length,iris$Species))
#Species를 기준으로 iris$Sepal.Length를 분류
gg<-unstack(data.frame(iris$Sepal.Length,iris$Species))
str(gg)
unstack(data.frame(car$mpg,car$am))
unstack(data.frame(iris$Sepal.Length,iris$Species))
#unstack함수는 그룹별로 분할된 데이터의 길이가 동일하면 데이터프레임, 동일하지 않으면 리스트로 출력
g1<-unstack(data.frame(car$mpg,car$am))  #리스트
g2<-unstack(data.frame(iris$Sepal.Length,iris$Species))  #데이터프레임
summary(g1)
summary(g2)
tapply(iris$Sepal.Length,iris$Species,mean)
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length,iris$Species,sum)
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length[iris$Sepal.Length],iris$Species,sum)
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length,iris$Species,nrow)
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length,iris$Species,sum(nrow)
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length,iris$Species,sum(nrow))
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length,iris$Species,length)
str(car)
tapply(mpg, list(cyl,am), mean)
with(car,tapply(mpg, list(cyl,am), mean))
with(car,aggregate(mpg, list(cyl,am),mean))
with(car,aggregate(mpg, list(Cylinder=cyl,Transmission=am),mean))
car[c(1:6)]
#car[c(1:6)] 변수의 평균, 실린더 개수와 변속기 유형의 조합에 따라...
aggregate(car[c(1:6)],list(car$cyl,car$am),mean)
#아이리스 꽃 종류별 측정 변수별 요약
str(iris)
aggregate(iris[c(1:4)],list(iris$Species),mean)
#by함수: 데이터프레임을 그룹별 데이터를 처리
by(iris, iris$Species, summary)
by(iris,iris$Species, function(x) mean(x$Sepal.Length))
rowSum(iris[-5], iris$Species)
rowsum(iris[-5], iris$Species)
#번주별 관측값 개수
tabulate(car$gear)
table(car$gear)
1:length(tabulate(car$gear))
#번주별 관측값 개수(범주별 개수가 몇개 있는지)
gc<-tabulate(car$gear)
names(gc)<-1:length(tabulate(car$gear))
gc
xtabs(~am, car)
xtabs(~am,+gear car)
xtabs(~am+gear,car)
aggregate(mpg~cyl+am,car, mean)
with(car, aggregate(mpg,list(cyl,am),mean))
airquality
filter(airquality,month==6)
filter(airquality,Month==6)
#filter 조건을 만족하는 행 추출
air<-cfilter(airquality,Month==6)
#filter 조건을 만족하는 행 추출
air<-filter(airquality,Month==6)
head(air)
airquality[airquality$Month==6]
airquality[airquality$Month==6,]
subset(airquality, airquality==6)
subset(airquality, airquality$Month==6)
subset(airquality, subset=Month==6)
subset(airquality, subset=(Month==6))
subset(airquality, subset=(Month==6))
air<-filter(airquality, Month==6,Temp>90)
air
air<-filter(airquality, Ozone>80 | Temp>90)
# 1. Survived 열 요약
# - 생존자/사망자 전체 비율
# - 성별에 따른 생존자/사망자
titanic<-read.csv('train.csv',na.strings = "")
table(titanic$Survived)
#or
proportions(titanic$Survived)
proportions(table(titanic$Survived))
str(titanic)
str(iris)
iris$Sepal.Length
class(iris$Sepal.Length)
# - 성별에 따른 생존자/사망자
sex
with(titanic,tapply(Survived,sex,mean))
with(titanic,tapply(Survived,list(sex),mean))
with(titanic,tapply(Survived,Sex,mean))
with(titanic,tapply(Survived,list(Sex),mean))
# 2. Pclass 열 요약
# - 등실 비율
str(titanic)
proportions(table(titanic$Pclass))
table(titanic[,c('Pclass','Survived')]
table(titanic[,c('Pclass','Survived')])
titanic[,c('Pclass','Survived')]
table(titanic[,c('Pclass','Survived')])
head(titanic[,c('Pclass','Survived')])
table(titanic[,c('Pclass','Survived')])
#or
with(titanic,tapply(Survived,Pclass,mean))
# - 등실에 따른 생존자/사망자 비율
proportions(table(titanic[,c('Pclass','Survived')]),1)
#or
with(titanic,tapply(Survived,Pclass,mean))
with(titanic,tapply(Survived,list(Pclass),mean))
# 3. Age 열
# - 나이대를 구분한 후, 각 나이대별 생존율
titanic$ages<-cut(titanic$Age,
breaks = c(0,10,20,30,40,50,max(titanic$Age)+1),
right=FALSE,
labels=c('10s','20s','30s','40s','50s')
)
proportions(table(titanic[,c('ages','Survived')]),1)
# 4. Fare 열
# - 운임을 전체 5개 구간으로 분리한 후,
# 각 구간별 생존율
titanic$ares<-cut(titanic$Fare,
breaks = 5,
include.lowest = TRUE)
titanic$ares
proportions(table(titanic[,c('fares','Survived')]),1)
# 4. Fare 열
# - 운임을 전체 5개 구간으로 분리한 후,
# 각 구간별 생존율
titanic$ares<-cut(titanic$Fare,
breaks = 5,
include.lowest = TRUE)
proportions(table(titanic[,c('fares','Survived')]),1)
# 4. Fare 열
# - 운임을 전체 5개 구간으로 분리한 후,
# 각 구간별 생존율
titanic$fares<-cut(titanic$Fare,
breaks = 5,
include.lowest = TRUE)
proportions(table(titanic[,c('fares','Survived')]),1)
# 5. Name 열
# - 호칭을 제외한 이름에서 자음과 모음의 비율
# - 성별에 따른 자음과 모음의 비율
#자음/모음 -> consonant.vowel.ratio
titanic$name
# 5. Name 열
# - 호칭을 제외한 이름에서 자음과 모음의 비율
# - 성별에 따른 자음과 모음의 비율
#자음/모음 -> consonant.vowel.ratio
titanic$Name
read.csv('train.csv')
read.csv('test.csv')
train<-read.csv('train.csv',na.strings = '')
test<-read.csv('test.csv',na.strings = '')
train
summary(train)
train$Prediction<-ifelse(train$Sex=='male',0,1)
head(train)
#train 정확도
train$Survived
sum(train$Survived==train$Prediction)
#test 적용
test$Survived<-ifelse(test$Sex=='male',0,1)
head(test)
submissions<-test[,c('PassengerId',"Survived")]
submissions
write.csv(submissions,file='submissions.csv',row.names = F)
#test 적용
test$Survived<-ifelse(test$Sex=='male',0,1)
head(test)
write.csv(submissions,file='submissions.csv',row.names = F)
#2
is.na(titanic$Age)
titanic$Pclass
mpc<-mean(titanic$Pclass)
mna<-mean(titanic$Name)
Name
titanic$Name
head(titanic)
iris
target<-c(4.0, 3.0, 1.5, 0.15)
new<-rbind(iris,target)
new
tail(new)
msl<-mean(new$Sepal.Length)
msw<-mean(new$Sepal.Width)
mpl<-mean(new$Petal.Length)
mpw<-mean(new$Petal.Width)
ssl<-sd(new$Sepal.Length)
ssw<-sd(new$Sepal.Width)
spl<-sd(new$Petal.Length)
spw<-sd(new$Petal.Width)
new[1:4]
new[1:4]
new[1:4]
t(new[1:4])
dim(t(new[1:4]))
infomat<-t(new[1:4])
ssl
#표준화=(각 data-평균)/표준편차
infomat<-(infomat-c(msl,msw,mpl,mpw))/c(ssl,ssw,spl,spw)
infomat
dist<-(infomat-infomat[,151])^2
dist<-sqrt(colSums(dist))
data.frame(dist)
iris.copy<-iris
class(iris.copy$Species)
#character타입으로 변경
class(as.character(iris.copy$Species))
iris.copy$Sepal.Ration<-iris.copy$Sepal.Length/iris.copy$Sepal.Width
head(iris.copy)
data.frame(dist)
new<-cbind(new,dist)
new
key<-sort(new$dist)[10]
summary(new$Species[new$dist<=key])
x<-1:20
dim(x)<-c(4,5)
apply(x,1,max)
x<-1:20
dim(x)<-c(4,5)
x
apply(x,1,max)
class(apply(x,1,paste,collapse=","))  #1:행, 2:열, 3: 3번째 차원(으로 paste가 되어짐)
x
apply(x,1,paste,collapse=",") #1:행, 2:열, 3: 3번째 차원(으로 paste가 되어짐)
x
apply(x,2,paste,collapse=",")
x<-1:24
dim(x)<-c(4,3,2)
x
apply(x,1,paste,collapse=",") #1:행, 2:열, 3: 3번째 차원(으로 paste가 되어짐)
apply(x,2,paste,collapse=",")
apply(x,3,paste,collapse=",")
apply(x,c(1,2),paste,collapse=",")  #행과 열이 교차하는 원소로 구성됨
#타이타닉
str(Titanic)
#등급별 탑승 인원을 파악
apply(Titanic, 1, sum)
#성별(두번 째 차원)탑승 인원을 파악
apply(Titanic, 2, sum)
#생존자별(네 번째 차원)탑승 인원을 파악
apply(Titanic, 4, sum)
#생존자별(네 번째 차원)탑승 인원을 파악
apply(Titanic, 4, sum)
#승객 등급별 생존자 통계를 알고싶다면?
apply(Titanic,c(1,4),sum)
#lapply(),sapply:데이터가 리스트 or 벡터일 때 사용
#인수가 2개, 첫번째 인수에는 데이터, 두번째 인수에는 함수
#lapply함수 결과:항상 리스트 형식으로 반환
#sapply함수 결과: 벡터 또는 행렬로 단순화 해서 반환 #simplify
#벡터는 길이가 1,행렬은 길이가 2이상 이면서 모두 같은 경우
#길이가 2이상이면서 서로 다른경우에는 리스트로 출력
exams<-list(s1=c(80,70,60,50,100),
s2=c(80,40,60,50),
s3=c(30,70,60,50,100,90),
s4=c(80,60,60,50,100)
)
exams
lapply(exams,length)  #출력 결과가 리스트로 나옴, 길이가 모두 1
sapply(exams,length)  #길이가 1이기 때문에 벡터로 반환
lapply(exams,mean)
sapply(exams,mean)
lapply(exams,length)  #출력 결과가 리스트로 나옴, 길이가 모두 1
sapply(exams,length)  #길이가 1이기 때문에 벡터로 반환
lapply(exams,mean)
sapply(exams,mean)
lapply(exams,sd)
sapply(exams,sd)
sapply(exams,range)  #길이가 2로 모두 동일함(따라서 출력 결과가 행렬로 나옴)
range(exams)
exams
sapply(exams,range)  #길이가 2로 모두 동일함(따라서 출력 결과가 행렬로 나옴)
range(exams)
lapply(exams,length)  #출력 결과가 리스트로 나옴, 길이가 모두 1
lapply(exams,range)
sapply(exams,range)  #길이가 2로 모두 동일함(따라서 출력 결과가 행렬로 나옴)
#lapply,sapply는 데이터프레임에 대해 사용가능
str(iris)
lapply(iris,class)
#sapply(iris,mean) #에러 남
#따라서 sapply(iris,사용자함수)
sapply(iris,function(x) ifelse(is.numeric(x),mean(x),NA))
#mapply():적용하고자 하는 함수가 벡터연산을 지원하지 않을 때 유용하게 사용 가능
mapply(rep,1:4,4:1)
#집단 요약(그룹을 기준으로 요약)
#벡터를 집단별로 분할(split,unstack)
car<-mtcars
car$am
car<-mtcars
car<-within(car,
am<-factor(am,
levels=c(0,1),
labels=c('Automatic','Manual'))
)
str(car)
#mpg를 변속기 종류(2가지)에 따라 분할
g<-split(car$mpg, car$am)
g
mean(g[[1]])
mean(g[[2]])
mean(g[['Manual']])
sapply(g,mean)
#split과 유사한 unstack함수
data.frame(car$mpg,car$am)
unstack(data.frame(car$mpg,car$am))
#Species를 기준으로 iris$Sepal.Length를 분류
gg<-unstack(data.frame(iris$Sepal.Length,iris$Species))
gg
#unstack함수는 그룹별로 분할된 데이터의 길이가 동일하면 데이터프레임, 동일하지 않으면 리스트로 출력
g1<-unstack(data.frame(car$mpg,car$am))  #리스트
g1
g2<-unstack(data.frame(iris$Sepal.Length,iris$Species))  #데이터프레임
g2
#summary함수는 데이터프레임에 대해 기술통계를 구해주는 함수
summary(g1) #summary안나옴
summary(g2) #summary나옴
tapply(iris$Sepal.Length,iris$Species,mean)
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length,iris$Species,length)
str(iris)
str(car)
#실린더(cyl)개수별 am 유형별 조합에 따른 mpg평균
#      a    m
#  4
#  6
#  8
with(car,tapply(mpg, list(cyl,am), mean))
car$cyl
car[c(1:6)]
head(car[c(1:6)])
#car[c(1:6)] 변수의 평균, 실린더 개수와 변속기 유형의 조합에 따라...
aggregate(car[c(1:6)],list(car$cyl,car$am),mean)
#아이리스 꽃 종류별 측정 변수별 요약
str(iris)
aggregate(iris[c(1:4)],list(iris$Species),mean)
#by함수: 데이터프레임을 그룹별 데이터를 처리
by(iris, iris$Species, summary)
by(iris,iris$Species, function(x) mean(x$Sepal.Length))
#by함수: 데이터프레임을 그룹별 데이터를 처리
by(iris, iris$Species, summary)
by(iris,iris$Species, function(x) mean(x$Sepal.Length))
rowsum(iris[-5], iris$Species)
#번주별 관측값 개수(범주별 개수가 몇개 있는지)
car$gear
gc<-tabulate(car$gear)
gc
1:length(tabulate(car$gear))
names(gc)<-1:length(tabulate(car$gear))
gc
table(car$gear)
#xtabs함수: table함수와 동일한 기능 수행, 포뮬러 사용
#~기준으로 오른쪽에 있는 것 기준으로 왼쪽을 출력하겠다
xtabs(~am, car)
xtabs(~am+gear,car)
car$gear
#포뮬러: mpg~cyl+am
#cyl와 am 유형별 mpg열의 평균을 구하시오.
aggregate(mpg~cyl+am,car, mean)
#같은 구문임
with(car, aggregate(mpg,list(cyl,am),mean))
airquality[airquality$Month==6,]
subset(airquality, subset=(Month==6))
#filter 조건을 만족하는 행 추출
air<-filter(airquality,Month==6)
head(air)
#filter 조건을 만족하는 행 추출
air<-filter(airquality,Month==6)
head(air)
airquality[airquality$Month==6,]
#filter 조건을 만족하는 행 추출
air<-filter(airquality,Month==6)
head(air)
#filter 조건을 만족하는 행 추출
air<-filter(airquality,Month=6)
#filter 조건을 만족하는 행 추출
air<-filter(airquality,Month==6)
#filter 조건을 만족하는 행 추출
air<-filter(airquality,Month==6)
head(air)
#filter 조건을 만족하는 행 추출
air<-filter(airquality,airquality$Month==6)
head(air)
#filter 조건을 만족하는 행 추출
head(airquality)
air<-filter(airquality,Month==6)
head(air)
air<-filter(airquality,Month==6)
head(air)
air<-filter(airquality,Month==6)
head(air)
airquality[airquality$Month==6,]
subset(airquality, subset=(Month==6))
air<-filter(airquality, Month==6,Temp>90)  #,는 and연산
# 1. Survived 열 요약
# - 생존자/사망자 전체 비율
titanic<-read.csv('train.csv',na.strings = "")
proportions(table(titanic$Survived))
str(titanic)
proportions(table(titanic$Survived))
# 1. Survived 열 요약
# - 생존자/사망자 전체 비율
titanic<-read.csv('train.csv',na.strings = "")
titanic$Survived)
table(titanic$Survived)
proportions(table(titanic$Survived))
with(titanic,tapply(Survived,Sex,mean))
with(titanic,tapply(Survived,list(Sex),mean))
# 2. Pclass 열 요약
# - 등실 비율
str(titanic)
proportions(table(titanic$Pclass))
table(titanic[,c('Pclass','Survived')])
# - 등실에 따른 생존자/사망자 비율
proportions(table(titanic[,c('Pclass','Survived')]),1)
# - 등실에 따른 생존자/사망자 비율
table(titanic[,c('Pclass','Survived')])
table(titanic[,c('Pclass','Survived')])
head(titanic[,c('Pclass','Survived')])
#or
with(titanic,tapply(Survived,list(Pclass),mean))
#or
with(titanic,tapply(Survived,list(Pclass),mean))
with(titanic,tapply(Death,list(Pclass),mean))
with(titanic,tapply(death,list(Pclass),mean))
with(titanic,tapply(Survived[Survived==0],list(Pclass),mean))
with(titanic,tapply(Survived==0,list(Pclass),mean))
#or
with(titanic,tapply(Survived,list(Pclass),mean))
with(titanic,tapply(Survived==0,list(Pclass),mean))
# 3. Age 열
# - 나이대를 구분한 후, 각 나이대별 생존율
max(titanic$Age)
# 3. Age 열
# - 나이대를 구분한 후, 각 나이대별 생존율
head(titanic$Age)
# 3. Age 열
# - 나이대를 구분한 후, 각 나이대별 생존율
max(titanic$Age)
# 3. Age 열
# - 나이대를 구분한 후, 각 나이대별 생존율
max(unlist(titanic$Age))
# 3. Age 열
# - 나이대를 구분한 후, 각 나이대별 생존율
max(titanic$Age)
# 3. Age 열
# - 나이대를 구분한 후, 각 나이대별 생존율
max(titanic$Age)
# 3. Age 열
# - 나이대를 구분한 후, 각 나이대별 생존율
max(titanic$Age)+1
titanic$ages<-cut(titanic$Age,
breaks = c(0,10,20,30,40,50,max(titanic$Age)+1),
right=FALSE,
labels=c('10s','20s','30s','40s','50s')
)
titanic$ages
# 3. Age 열
# - 나이대를 구분한 후, 각 나이대별 생존율
max(titanic$Age)
# 3. Age 열
# - 나이대를 구분한 후, 각 나이대별 생존율
max(titanic$Age,na.rm = T)
titanic$ages<-cut(titanic$Age,
breaks = c(0,10,20,30,40,50,max(titanic$Age)+1),
right=FALSE,
labels=c('10s','20s','30s','40s','50s')
)
titanic$ages
proportions(table(titanic[,c('ages','Survived')]),1)
#or
with(titanic,tapply(Survived,list(ages),mean))
# 4. Fare 열
# - 운임을 전체 5개 구간으로 분리한 후,
# 각 구간별 생존율
titanic$fares<-cut(titanic$Fare,
breaks = 5,
include.lowest = TRUE)
proportions(table(titanic[,c('fares','Survived')]),1)
with(titanic,tapply(Survived,list(fares),mean))
with(titanic,tapply(Survived==0,list(fares),mean))
# 5. Name 열
# - 호칭을 제외한 이름에서 자음과 모음의 비율
# - 성별에 따른 자음과 모음의 비율
#자음/모음 -> consonant.vowel.ratio
titanic$Name
# 5. Name 열
# - 호칭을 제외한 이름에서 자음과 모음의 비율
# - 성별에 따른 자음과 모음의 비율
#자음/모음 -> consonant.vowel.ratio
head(titanic$Name,20)
#자음/전체, 모음/전체
aggregate(titanic[c('consonant.ratio','vowel.ratio')],list(titanic$Sex),mean)
#자음/전체, 모음/전체
aggregate(titanic[c('consonant.ratio','vowel.ratio')],titanic$Sex,mean)
aggregate(titanic[c('consonant.ratio','vowel.ratio')],list(sex=titanic$Sex),mean)
for (i in 1:nrow(titanic)){
titanic$realname[i] <- gsub('\\s{1}.{2,}[.]',replacement = '',titanic$Name[i])
lst<-unlist(strsplit(titanic$realname[i],split=''))
lst<-grep('[a-zA-Z]{1}',lst,value=TRUE)
vowel <- grep('[aeiouAEIOU]',lst,value=TRUE)
titanic$vowel.ratio[i] <- length(vowel)/length(lst)
titanic$consonant.ratio[i] <- (length(lst)-length(vowel))/length(lst)
}
str(titanic)
#자음/모음
with(titanic,tapply(consonant.vowel.ratio,list(Sex),mean))
#자음/전체, 모음/전체
aggregate(titanic[c('consonant.ratio','vowel.ratio')],list(titanic$Sex),mean)
aggregate(titanic[c('consonant.ratio','vowel.ratio')],list(sex=titanic$Sex),mean)
# 6. Embarked 열
# - 각 승선 항구별 생존율
with(titanic,tapply(Survived,list(Embarked),mean))
