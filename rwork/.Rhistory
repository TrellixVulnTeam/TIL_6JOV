df[order(df$w,df$y),]
df[1]
df[order(df$z,df$y),]
df$w
xtfrm(df$w)  #
order(-xtfrm(df$w),df$y)
index<-order(-xtfrm(df$w),df$y)
df[index,]
#퀴즈3
#iris의 종(species)별로 내림차순 정렬, sepal.length기준으로 오름차순 정렬
iris
df[order(iris$Species,iris$Sepal.Length),]
iris[order(iris$Species,iris$Sepal.Length),]
ggplot2::midewest
ggplot2::midwest
as.data.frame(ggplot2::midwest)
####
midwest<-as.data.frame(ggplot2::midwest
# 1. mtcars데이터 weight열 추가, 무게가 중위수보다 큰 자동차는 heavy, 그렇지 않은 자동차는 light를 저장
# - 각 종류별 데이터 건수 출력, 비율
car<-mtcars
# 1. mtcars데이터 weight열 추가, 무게가 중위수보다 큰 자동차는 heavy, 그렇지 않은 자동차는 light를 저장
# - 각 종류별 데이터 건수 출력, 비율
car<-mtcars
car$weight<-'light'
car
# 1. mtcars데이터 weight열 추가, 무게가 중위수보다 큰 자동차는 heavy, 그렇지 않은 자동차는 light를 저장
# - 각 종류별 데이터 건수 출력, 비율
car<-mtcars
car
car$weight<-'light'
car$weight[car$]
# 1. mtcars데이터 weight열 추가, 무게가 중위수보다 큰 자동차는 heavy, 그렇지 않은 자동차는 light를 저장
# - 각 종류별 데이터 건수 출력, 비율
mtcars
# 1. mtcars데이터 weight열 추가, 무게가 중위수보다 큰 자동차는 heavy, 그렇지 않은 자동차는 light를 저장
# - 각 종류별 데이터 건수 출력, 비율
data(mtcars)
# 1. mtcars데이터 weight열 추가, 무게가 중위수보다 큰 자동차는 heavy, 그렇지 않은 자동차는 light를 저장
# - 각 종류별 데이터 건수 출력, 비율
mtcars
# 1. mtcars데이터 weight열 추가, 무게가 중위수보다 큰 자동차는 heavy, 그렇지 않은 자동차는 light를 저장
# - 각 종류별 데이터 건수 출력, 비율
cars<-mtcars
cars$weight<-'light'
cars
cars$weight[cars$wt>median(car$wt)]<-'heavy'
car
cars$weight[cars$wt>median(cars$wt)]<-'heavy'
car
# 1. mtcars데이터 weight열 추가, 무게가 중위수보다 큰 자동차는 heavy, 그렇지 않은 자동차는 light를 저장
# - 각 종류별 데이터 건수 출력, 비율
cars<-mtcars
cars$weight<-'light'
cars$weight[cars$wt>median(cars$wt)]<-'heavy'
car
data("mtcars")
car<-mtcars
car$weight<-'light'
car$weight[car$wt>median(car$wt)]<-'heavy'
car
table(car$weight)
#비율
table(car$weight)
#비율
table(car$weight)/nrow(car)
#비율
nrow(car)
# 2. mtcars 데이터셋 열들이 왼쪽에서 오른쪽으로 오름차순으로 배치되도록 작성
colnames(car)
index<-sort(colnames(car))
car[,index]
# 3. iris데이터에서 70% 데이터를 무작위 표본추출
sample(1:nrow(iris),nrow(iris)*0.7)
# 3. iris데이터에서 70% 데이터를 무작위 표본추출
iris[sample(1:nrow(iris),nrow(iris)*0.7),]
# 3. iris데이터에서 70% 데이터를 무작위 표본추출
str(iris[sample(1:nrow(iris),nrow(iris)*0.7),])
# 4. ggplot2 패키지에는 미국 동북중부 437개 지역의 인구통계 정보를 담은 midwest라는 데이터가 포함되어 있음.
# midwest 데이터를 사용하여,
# 불러오기 : midwest<-as.data.frame(ggplot2::midwest)
# - ggplot2 의 midwest 데이터를 데이터 프레임 형태로 불러와서 데이터의 특성을 파악
head(midwest)
# 4. ggplot2 패키지에는 미국 동북중부 437개 지역의 인구통계 정보를 담은 midwest라는 데이터가 포함되어 있음.
# midwest 데이터를 사용하여,
# 불러오기 : midwest<-as.data.frame(ggplot2::midwest)
# - ggplot2 의 midwest 데이터를 데이터 프레임 형태로 불러와서 데이터의 특성을 파악
midwest<-as.data.frame(ggplot2::midwest)
head(midwest)
# - poptotal(전체 인구)을 total 로, popasian(아시아 인구)을 asian 으로 변수명을 수정
midwest<-rename(midwest,c(total=poptotal,asian=popasian))
# - total, asian 변수를 이용해 '전체 인구 대비 아시아 인구 백분율' 파생변수 생성
midwest$perasian<-midwest$asian/midwest$total
midwest
# - 아시아 인구 백분율 전체 평균을 구하고, 평균을 초과하면 "large", 그 외에는 "small"을 부여하는 파생변수 생성
midwest$average.asian<-'small'
midwest$average.asian[midwest$perasian>mena(midwest$perasian)]<-'large'
midwest$average.asian[midwest$perasian>mean(midwest$perasian)]<-'large'
head(midwest)
# - "large"와 "small"에 해당하는 지역이 얼마나 되는지 빈도수를 출력
table(midwest$average.asian)
# 5. 타이타닉 데이터 분석
# -타이타닉 데이터 불러오기
titanic<-read.csv('train.csv',na.strings = '')
head(titanic)
# - 생존자 수, 사망자 수 출력
table(titanic$Survived)
# - pclass, embarked 별 승객수 출력(비율)
table(titanic$Pclass)/nrow(titanic)
table(titanic$Embarked)/nrow(titanic)
#or
pclass.table <- as.data.frame(table(titanic$Pclass))
pclass.table
# - Name에서 호칭 종류 출력, 호칭 종류 별 승객수 출력
titanic$Name
# - Name에서 호칭 종류 출력, 호칭 종류 별 승객수 출력
str(titanic$Name)
# - Name에서 호칭 종류 출력, 호칭 종류 별 승객수 출력
strsplit(titanic$Name,split=' ')
# - Name에서 호칭 종류 출력, 호칭 종류 별 승객수 출력
str(strsplit(titanic$Name,split=' '))
# - Name에서 호칭 종류 출력, 호칭 종류 별 승객수 출력
name2<-unlist(strsplit(titanic$Name,split=' '))
name2<-grep('^[A-Z][a-z]+[.]',name2,value=TRUE)
table(name2)
# - 호칭을 아래와 같이 변경하여 name2열에 추가
# * "Mlle", "Ms", "Lady", "Dona" 는 "Miss"로 변경
# * "Mme"는  "Mrs"로 변경
# * "Capt", "Col", "Major", "Dr", "Rev", "Don",  "Sir", "the Countess", "Jonkheer"는 "Officer"로 변경
# * "Mr", "Mrs", "Miss"는 그대로
# * 나머지 호칭은 "Others"
miss <-c("Mlle.", "Ms.", "Lady.", "Dona.",'Miss.')
mrs <-c('Mme.','Mrs.')
officer<-c("Capt.", "Col.", "Major.", "Dr.", "Rev.", "Don.",  "Sir.", "the Countess.", "Jonkheer.")
mr<-c('Mr.')
titanic$name2<-'Others'
titanic[name2 %in% miss,]$name2 <-'Miss'
titanic[name2 %in% mrs,]$name2 <-'Mrs'
titanic[name2 %in% officer,]$name2 <-'Officer'
titanic[name2 %in% mr,]$name2 <-'Mr'
titanic
# -name2 열을 factor로(5가지 범주) 변환
titanic$name2<-as.factor(titanic$name2)
str(titanic$name2)
# -name2열의 호칭별 인원수 출력
table(titanic$name2)
# -호칭 정보를 바탕으로 나이(Age) 결측값 대체(호칭 별 나이의 평균값)
head(titanic)
# -age열의 구간별 인원수 출력
# 10대 미만, 10대, 20대, 30대, 40대, 50대 이상
max(titanic$Age)
# -호칭 정보를 바탕으로 나이(Age) 결측값 대체(호칭 별 나이의 평균값)
head(titanic)
mean.miss<-mean(titanic$Age[titanic$name2=='Miss'],na.rm = T)
titanic$Age[titanic$name2=='Miss'&is.na(titanic$Age)]<-mean.miss
mean.mrs<-mean(titanic$Age[titanic$name2=='Mrs'],na.rm = T)
titanic$Age[titanic$name2=='Mrs'&is.na(titanic$Age)] <-mean.mrs
mean.officer<-mean(titanic$Age[titanic$name2=='Officer'],na.rm = T)
titanic$Age[titanic$name2=='Officer'&is.na(titanic$Age)] <-mean.officer
mean.mr<-mean(titanic$Age[titanic$name2=='Mr'],na.rm = T)
titanic$Age[titanic$name2=='Mr'&is.na(titanic$Age)] <-mean.mr
mean.others<-mean(titanic$Age[titanic$name2=='Others'],na.rm = T)
titanic$Age[titanic$name2=='Others'&is.na(titanic$Age)] <-mean.others
# -age열의 구간별 인원수 출력
# 10대 미만, 10대, 20대, 30대, 40대, 50대 이상
max(titanic$Age)
cut(x=iris$Sepal.Width, breaks=c(0,1,2,3,4,5))
# -age열의 구간별 인원수 출력
# 10대 미만, 10대, 20대, 30대, 40대, 50대 이상
max(titanic$Age)
cut(titanic$Age,breaks=c(0,10,20,30,40,50,81),right=FASSE)
# -age열의 구간별 인원수 출력
# 10대 미만, 10대, 20대, 30대, 40대, 50대 이상
max(titanic$Age)
cut(titanic$Age,breaks=c(0,10,20,30,40,50,81),right=FALSE)
table(cut(titanic$Age,breaks=c(0,10,20,30,40,50,81),right=FALSE)
table(cut(titanic$Age,breaks=c(0,10,20,30,40,50,81),right=FALSE))
table(cut(titanic$Age,breaks=c(0,10,20,30,40,50,81),right=FALSE))
# -cabin 컬럼의 1번째 글자 출력(NA는 제외)
substr(titanic$Cabin[complete.cases(titanic$Cabin)],1,1)
# - fare열 값에 대해 최대/최소/평균/표준편차 출력
summary(titanic$Fare)
# - sibsp + parch를 더하여 새롭게 family열에 저장
head(titanic)
titanic$family <- titanic$SibSp+titanic$Parch
titanic
titanic$family <- titanic$SibSp+titanic$Parch
titanic
#or
order(names(mtcars))
mtcars[,order(names(mtcars))]
#or
set.seed(1)
view(midwest)
View(midwest)
#or
matrix(sample(100,15),ncol=3)
colnames(mydate)<-LETTERS[seq(1,3)]
#or
mydata<-matrix(sample(100,15),ncol=3)
colnames(mydate)<-LETTERS[seq(1,3)]
#or
mydata<-matrix(sample(100,15),ncol=3)
colnames(mydate)<-LETTERS[seq(1,3)]
#or
mydata<-matrix(sample(100,15),ncol=3)
colnames(mydata)<-LETTERS[seq(1,3)]
mydata
sprintf("s-%d",seq(5))
rownames(mydata)<-sprintf("s-%d",seq(5))
mydata
prop.table(mydata)
sum(prop.table(mydata))
library(dplyr)
prop.table(mydata) %>% sum
prop.table(mydata,1)
#or
proportions(titanic$Survived)
proportions(titanic$Embarked)
#or
proportions(titanic$Survived)
proportions(titanic$Embarked)
prop.table
#or
lev <- levels(factor(titanic$name2))
lev
iris.copy<-iris
class(iris.copy$Species)
#character타입으로 변경
class(as.character(iris.copy$Species))
iris.copy$Sepal.Length/iris.copy$Sepal.Width
iris.copy$Sepal.Ration<-iris.copy$Sepal.Length/iris.copy$Sepal.Width
head(iris.copy)
iris
iris.copy<-iris
transform(iris.copy,
Species=as.character(Species), #iris.copy$Species대신 이렇게 써도 됨,
sepalRation=Sepal.Length/Sepal.Width
)
iris.trans
iris.trans<-transform(iris.copy,
Species=as.character(Species), #iris.copy$Species대신 이렇게 써도 됨,
sepalRation=Sepal.Length/Sepal.Width
)
iris.trans
#apply():적용하고자 하는 데이터가 행렬 or 배열일 때 사용 가능
x<-1:20
dim(x)<-c(4,5)
x
apply(x,1,max)
x<-1:24
dim(x)
dim(x)<-c(4,3,2)
x
apply(x,1,paste)
apply(x,1,paste,collapse=",")  #1:행, 2:열, 3: 3번째 차원(으로 paste가 되어짐)
apply(x,2,paste,collapse=",")
apply(x,3,paste,collapse=",")
apply(x,c(1,2),paste,collapse=",")
class(apply(x,1,paste,collapse=","))  #1:행, 2:열, 3: 3번째 차원(으로 paste가 되어짐)
#타이타닉
Titanic
#타이타닉
str(Titanic)
#등급별 탑승 인원을 파악
apply(Titanic, 1, sum)
#성별(두번 째 차원)탑승 인원을 파악
apply(Titanic, 2, sum)
#생존자별(네 번째 차원)탑승 인원을 파악
apply(Titanic, 4, sum)
#승객 등급별 생존자 통계를 알고싶다면?
apply(Titanic,c(1,4),sum)
#lapply(),sapply:데이터가 리스트 or 벡터일 때 사용
#인수가 2개, 첫번째 인수에는 데이터, 두번째 인수에는 함수
#lapply함수 결과:항상 리스트 형식으로 반환
#sapply함수 결과: 벡터 또는 행렬로 단순화 해서 반환 #simplify
#벡터는 길이가 1,행렬은 길이가 2이상 이면서 모두 같은 경우
#길이가 2이상이면서 서로 다른경우에는 리스트로 출력
list(s1=c(80,70,60,50,100),
s2=c(80,40,60,50),
s3=c(30,70,60,50,100,90),
s4=c(80,60,60,50,100),
)
#lapply(),sapply:데이터가 리스트 or 벡터일 때 사용
#인수가 2개, 첫번째 인수에는 데이터, 두번째 인수에는 함수
#lapply함수 결과:항상 리스트 형식으로 반환
#sapply함수 결과: 벡터 또는 행렬로 단순화 해서 반환 #simplify
#벡터는 길이가 1,행렬은 길이가 2이상 이면서 모두 같은 경우
#길이가 2이상이면서 서로 다른경우에는 리스트로 출력
list(s1=c(80,70,60,50,100),
s2=c(80,40,60,50),
s3=c(30,70,60,50,100,90),
s4=c(80,60,60,50,100)
)
exams
#lapply(),sapply:데이터가 리스트 or 벡터일 때 사용
#인수가 2개, 첫번째 인수에는 데이터, 두번째 인수에는 함수
#lapply함수 결과:항상 리스트 형식으로 반환
#sapply함수 결과: 벡터 또는 행렬로 단순화 해서 반환 #simplify
#벡터는 길이가 1,행렬은 길이가 2이상 이면서 모두 같은 경우
#길이가 2이상이면서 서로 다른경우에는 리스트로 출력
exams<-list(s1=c(80,70,60,50,100),
s2=c(80,40,60,50),
s3=c(30,70,60,50,100,90),
s4=c(80,60,60,50,100)
)
exams
laaply(exams,length)
lapply(exams,length)
sapply(exams,length)  #길이가 1이기 때문에 벡터로 반환
lapply(exams,mean)
sapply(exams,mean)
sapply(exams,sd)
s4=c(80,60,60,50,100)
range(s4)
sapply(exams,range)
#lapply,sapply는 데이터프레임에 대해 사용가능
str(iris)
lapply(iris,class)
sapply(iris,mean)
#sapply(iris,mean) #에러 남
#따라서 sapply(iris,사용자함수)
sapply(iris,function(x) ifelse(is.numeric(x),mean(x),NA))
#mapply():적용하고자 하는 함수가 벡터연산을 지원하지 않을 때 유용하게 사용 가능
mapply(rep,1:4,4:1)
#집단 요약(그룹을 기준으로 요약)
#벡터를 집단별로 분할(split,unstack)
car<-mtcars
within(car,
factor(am,
levels=c(0,1),
labels=c('Automatic','Manual'))
)
#집단 요약(그룹을 기준으로 요약)
#벡터를 집단별로 분할(split,unstack)
car<-mtcars
#집단 요약(그룹을 기준으로 요약)
#벡터를 집단별로 분할(split,unstack)
car<-mtcars
car<-within(car,
am<-factor(am,
levels=c(0,1),
labels=c('Automatic','Manual'))
)
str(car)
#mpg를 변속기 종류(2가지)에 따라 분할
g<-split(car$mpg, car$am)
g
car
#mpg를 변속기 종류(2가지)에 따라 분할
g<-split(car$mpg, car$am)
g
class(g)
g[1]
g[[1]
g[[1]]
g[[1]]
mean(g[[1]])
mean(g[['Manual']])
sapply(g,mean)
car
car$mpg
car$am
data.frame(car$mpg,car$am)
unstack(data.frame(car$mpg,car$am))
iris$Sepal.Length
unstack(data.frame(iris$Sepal.Length,iris$Species))
#Species를 기준으로 iris$Sepal.Length를 분류
gg<-unstack(data.frame(iris$Sepal.Length,iris$Species))
str(gg)
unstack(data.frame(car$mpg,car$am))
unstack(data.frame(iris$Sepal.Length,iris$Species))
#unstack함수는 그룹별로 분할된 데이터의 길이가 동일하면 데이터프레임, 동일하지 않으면 리스트로 출력
g1<-unstack(data.frame(car$mpg,car$am))  #리스트
g2<-unstack(data.frame(iris$Sepal.Length,iris$Species))  #데이터프레임
summary(g1)
summary(g2)
tapply(iris$Sepal.Length,iris$Species,mean)
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length,iris$Species,sum)
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length[iris$Sepal.Length],iris$Species,sum)
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length,iris$Species,nrow)
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length,iris$Species,sum(nrow)
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length,iris$Species,sum(nrow))
#종별 꽃 데이터의 개수를 출력
tapply(iris$Sepal.Length,iris$Species,length)
str(car)
tapply(mpg, list(cyl,am), mean)
with(car,tapply(mpg, list(cyl,am), mean))
with(car,aggregate(mpg, list(cyl,am),mean))
with(car,aggregate(mpg, list(Cylinder=cyl,Transmission=am),mean))
car[c(1:6)]
#car[c(1:6)] 변수의 평균, 실린더 개수와 변속기 유형의 조합에 따라...
aggregate(car[c(1:6)],list(car$cyl,car$am),mean)
#아이리스 꽃 종류별 측정 변수별 요약
str(iris)
aggregate(iris[c(1:4)],list(iris$Species),mean)
#by함수: 데이터프레임을 그룹별 데이터를 처리
by(iris, iris$Species, summary)
by(iris,iris$Species, function(x) mean(x$Sepal.Length))
rowSum(iris[-5], iris$Species)
rowsum(iris[-5], iris$Species)
#번주별 관측값 개수
tabulate(car$gear)
table(car$gear)
1:length(tabulate(car$gear))
#번주별 관측값 개수(범주별 개수가 몇개 있는지)
gc<-tabulate(car$gear)
names(gc)<-1:length(tabulate(car$gear))
gc
xtabs(~am, car)
xtabs(~am,+gear car)
xtabs(~am+gear,car)
aggregate(mpg~cyl+am,car, mean)
with(car, aggregate(mpg,list(cyl,am),mean))
airquality
filter(airquality,month==6)
filter(airquality,Month==6)
#filter 조건을 만족하는 행 추출
air<-cfilter(airquality,Month==6)
#filter 조건을 만족하는 행 추출
air<-filter(airquality,Month==6)
head(air)
airquality[airquality$Month==6]
airquality[airquality$Month==6,]
subset(airquality, airquality==6)
subset(airquality, airquality$Month==6)
subset(airquality, subset=Month==6)
subset(airquality, subset=(Month==6))
subset(airquality, subset=(Month==6))
air<-filter(airquality, Month==6,Temp>90)
air
air<-filter(airquality, Ozone>80 | Temp>90)
# 1. Survived 열 요약
# - 생존자/사망자 전체 비율
# - 성별에 따른 생존자/사망자
titanic<-read.csv('train.csv',na.strings = "")
table(titanic$Survived)
#or
proportions(titanic$Survived)
proportions(table(titanic$Survived))
str(titanic)
str(iris)
iris$Sepal.Length
class(iris$Sepal.Length)
# - 성별에 따른 생존자/사망자
sex
with(titanic,tapply(Survived,sex,mean))
with(titanic,tapply(Survived,list(sex),mean))
with(titanic,tapply(Survived,Sex,mean))
with(titanic,tapply(Survived,list(Sex),mean))
# 2. Pclass 열 요약
# - 등실 비율
str(titanic)
proportions(table(titanic$Pclass))
table(titanic[,c('Pclass','Survived')]
table(titanic[,c('Pclass','Survived')])
titanic[,c('Pclass','Survived')]
table(titanic[,c('Pclass','Survived')])
head(titanic[,c('Pclass','Survived')])
table(titanic[,c('Pclass','Survived')])
#or
with(titanic,tapply(Survived,Pclass,mean))
# - 등실에 따른 생존자/사망자 비율
proportions(table(titanic[,c('Pclass','Survived')]),1)
#or
with(titanic,tapply(Survived,Pclass,mean))
with(titanic,tapply(Survived,list(Pclass),mean))
# 3. Age 열
# - 나이대를 구분한 후, 각 나이대별 생존율
titanic$ages<-cut(titanic$Age,
breaks = c(0,10,20,30,40,50,max(titanic$Age)+1),
right=FALSE,
labels=c('10s','20s','30s','40s','50s')
)
proportions(table(titanic[,c('ages','Survived')]),1)
# 4. Fare 열
# - 운임을 전체 5개 구간으로 분리한 후,
# 각 구간별 생존율
titanic$ares<-cut(titanic$Fare,
breaks = 5,
include.lowest = TRUE)
titanic$ares
proportions(table(titanic[,c('fares','Survived')]),1)
# 4. Fare 열
# - 운임을 전체 5개 구간으로 분리한 후,
# 각 구간별 생존율
titanic$ares<-cut(titanic$Fare,
breaks = 5,
include.lowest = TRUE)
proportions(table(titanic[,c('fares','Survived')]),1)
# 4. Fare 열
# - 운임을 전체 5개 구간으로 분리한 후,
# 각 구간별 생존율
titanic$fares<-cut(titanic$Fare,
breaks = 5,
include.lowest = TRUE)
proportions(table(titanic[,c('fares','Survived')]),1)
# 5. Name 열
# - 호칭을 제외한 이름에서 자음과 모음의 비율
# - 성별에 따른 자음과 모음의 비율
#자음/모음 -> consonant.vowel.ratio
titanic$name
# 5. Name 열
# - 호칭을 제외한 이름에서 자음과 모음의 비율
# - 성별에 따른 자음과 모음의 비율
#자음/모음 -> consonant.vowel.ratio
titanic$Name
