#에러안나옴:with함수 안에서 사용한 변수를 함수 밖에서도 사용하고 싶으면 화살표 <<-이렇게
with(iris,{
stats<<-summary(Sepal.Length)
stats
})
stats
iris$Sepal.Ratio<-iris$Sepal.Length/iris$Sepal.Width
iris<-within(iris,Sepal.Ratio<-Sepal.Length/Sepal.Width)
iris
#sqldf 패키지:SQL 명령문을 사용할 수 있음
install.packages('sqldf') #패키지 설치
library(sqldf) #설치된 패키지를 프로그램에서 사용하기 위해 불러오기
mtcars
mtcars
sqldf('select*from mtcars')
sqldf('select cyl from mtcars')
sqldf('select cyl,hp,gear from mtcars')
sqldf('select * from mtcars', row.names = TRUE)
sqldf('select * from mtcars where mpg>30', row.names = TRUE)
sqldf('select * from mtcars where mpg>30 order by hp', row.names = TRUE)
state.x77
class(state.x77)
st<-state.x77 #배열
#st를 데이프레임으로 바꾸세요
st<-data.frame(st)
colnames(st)
rownames(st)
colnames(st)
#차원?
dim(st) #50개, 변수(피처) 8개
#행단위로 합계
rowSums(st)
#행단위 평균
rowMeans(st)
v1<-c(20,10,50,40,20)
v2<-c(300,200,100,700,600)
v3<-c('a','b','b','a','b')
df<-data.frame(v1,v2,v3)
df
#벡터 정렬
v1
sort(v1) #오름차순
sort(v1,decreasing = TRUE) #내림차순
#order(): 정렬 색인 값을 추출
v1
order(v1) #오름차순정렬했을 때,
v1[order(v1)]
df
order(v1) #오름
order(-v2) #내림
order(v2)
order(-v2) #내림
order(v3) #오름
#      기준1/기준2/기준3
df[order(v1,-v2,v3),]
df[order(v1),]
df[order(v1,-v2,v3),]
arrange(df, v1, desc(v2))
install.packages('plyr')
library(plyr)
arrange(df, v1, desc(v2))
arrange(df, v1, desc(v2))
sort(letters,decreasing = TRUE)
sort(letters,decreasing = TRUE)
x<-c(2,-1,3,7,0.5,8)
x[x]
x<-c(2,-1,3,7,0.5,8)
x[x]
x<-'We have a dream'
#nchar함수(텍스트 안에 문자의 개수 , 공백문자도 하나의 문자로 취급)
nchar(x)
length(x) #문자 벡터의 벡터 길이(문자열자체를 하나로 봄(원소 개수 1개))
length(c('we','have','a','dream'))  #백터 길이4
y<-c('we','have','a','dream')
length(y[4])
nchar(y[4])
nchar(y)
#대소문자 변경
x<-'We have a dream'
tolower(x)
toupper(x)
#문자 분리하는 함수:split()
strsplit(x,split=' ')
class(strsplit(x,split=" "))  #공백 문자로 구분된 각각의 단어들로 구성된 벡터가 리스트에 저장됨
#모든 문자 분리 됨
strsplit(x,split="")
#strsplit 결과가 리스트로 저장
#리스트->벡터
unlist(strsplit(x,split=" "))
#or
res<-strsplit(x,split=" ")[[1]]
res[4]
#or
res<-strsplit(x,split=" ")[[1]]
res
class(res)
res[4]
#or
res<-strsplit(x,split=" ")[[1]]
res
x1<-'We have a dream'
x2<-'How are you'
x3<-'I am fine'
myword<-c(x1,x2,x3)
length(myword)
myword
#리스트로 나옴
strsplit(myword,split=" ")
#i am fine 참조
strsplit(myword,split=" ")[[3]]
#fine 참조
strsplit(myword,split=" ")[[3]][3]
said<-'WHAT IS ESSENTIAL is invisible to the Eye'
said.word<-strsplit(said, " ")
#unique():유일한 단어를 추출해주는 함수
unique(said.word)
#벡터로 접근해야됨
tolower(unique(said.word[[1]]))
#정규화작업
iris[,-5]
#정규화작업
iris
#paste():문자열 결합 함수->하나의 문자열로 생성
paste('Everybody','wants','to','fly')
#paste():문자열 결합 함수->하나의 문자열로 생성
paste('Everybody','wants','to','fly')
paste(c('Everybody','wants','to','fly'))  #한개의 벡터가 되버림,따라서 결합 안됨
#이것도 역시 res가 벡터로 반환되기 때문에 결합하지 않고 따로 나옴
said<-'WHAT IS ESSENTIAL is invisible to the Eye'
res<-strsplit(said," ")[[1]]
paste(res)
#이것도 역시 res가 벡터로 반환되기 때문에 결합하지 않고 따로 나옴
said<-'WHAT IS ESSENTIAL is invisible to the Eye'
res<-strsplit(said," ")[[1]]
res
#이것도 역시 res가 벡터로 반환되기 때문에 결합하지 않고 따로 나옴
said<-'WHAT IS ESSENTIAL is invisible to the Eye'
res<-strsplit(said," ")[[1]]
res
#기본값으로 공백문자
paste('Everybody','wants','to','fly')
paste('Everybody','wants','to','fly',sep='-')
paste('Everybody','wants','to','fly',sep='')
#벡터를 인수로 준 경우에는 요소간 결합
heroes<-c('Batman','Captain America','Hulk')
colors<-c('Black','Blue','Green')
paste(colors,heroes)
paste('type',1)
paste('type',1:5)
#
c(1,2,3,4,5)
#
c(1,2,3,4,5)
c('type') #길이 1->길이 5로 변경됨(c('type','type','type','type','type'))
paste(heroes,"wants","to")
paste(c('Everybody','wants','to','fly'))
paste(c('Everybody','wants','to','fly'),collapse=" ")
heroes<-c('Batman','Captain America','Hulk')
sen<-paste(c('Everybody','wants','to','fly'))
sen
paste(heroes,sen[[2]],collapse=" and ")
#
heroes<-c('Batman','Captain America','Hulk')
paste(heroes,'wants','to','fly',collapse=", and ")
#paste함수에 sep옵션, collapse옵션
heroes<-c('Batman','Captain America','Hulk')
paste(heroes,'wants','to','fly',sep='-',collapse=';')
#outer():두 집합에 대해 가능한 모든 순서쌍으 ㅣ곱을 수행(카티전 곱)
outer(c(1,2,3),c(3,2,1))
asia.countries<-c("Korea","China","India")
info<-c('GDP','Population','Area')
outer(asia.countries,info, FUN=paste,sep="-")
#as.vector():행렬->벡터형식
out<-outer(asia.countries,info, FUN=paste,sep="-")
as.vector(out)
#
res<-out<-outer(asia.countries,asia.countries, FUN=paste,sep="-")
#lowe.tri():하삼각행렬 TRUE로 반환
res[lower.tri(res)]
#앞에 !붙이면 반전됨
res[!lower.tri(res)]
#lowe.tri():하삼각행렬 TRUE로 반환
lower.tri(res)
#앞에 !붙이면 반전됨
res[!lower.tri(res)]
substr('Data Analytics',1,4)
substr('Data Analytics',6,14)
#substring:텍스트의 특정 부분 문자열 추출, 끝위치 생략 가능
substring('Data Analytics',6)
#substring:텍스트의 특정 부분 문자열 추출, 끝위치 생략 가능
substring('Data Analytics',6)
#원소별로 부분 문자열 추출
myclass<-c('Data Analytics','Data Minig','Data Visualization')
substr(myclass,1,4)
substr(myclass,1,4)[1]
substr(myclass,nchar(myclass)-5,nchar(myclass))
#grep():New문자열이 포함된 단어의 인덱스를 추출
class(islands)
landmasses<-names(islands)
#grep():New문자열이 포함된 단어의 인덱스를 추출
islands
landmasses<-names(islands)
landmasses
landmasses<-names(islands)
landmasses
index<-grep(pattern="New",x=landmasses)
landmasses[index]
grep(pattern = "New",x=landmasses,value = TRUE)
#두 개 이상의 단어로 이루어진 대륙 또는 섬을 출력
grep(pattern = " ",x=landmasses,value = TRUE)
#or
landmasses[grep(pattern = " ",x=landmasses)]
txt<-'Data Anal is useful. Data Anal is interesting.'
sub(pattern = "Data",replacement = "Business",txt)
gsub(pattern = "Data",replacement = "Business",txt)
x<-c('input.csv','data.csv','big.csv')
gsub(pattern = ".csv",replacement = "",x)
#finance.yahoo.com->samsung
df<-read.csv("samsung.csv",header=TRUE,sep=",")
df
df2<-read.csv("samsung.csv")  #,header=TRUE,sep="," 디폴트
df2
read.csv('samsung.csv',header=FALSE,sep=',')
#정규표현식이 포함된 문자열 추출
words<-c('at','bat','cat','cheap','check','cheese','chick','hat','chase')
grep('che',words,value=TRUE)
#정규표현식이 포함된 문자열 추출
words<-c('at','bat','cat','cheap','check','cheese','chick','hat','chase')
grep('che',words,value=TRUE)
grep('che',words)
grep('at',words,value=TRUE)
#c또는 h가 포함된 문자열 검색
grep('[ch]',words,value=TRUE)
#a또는 t가 포함된 문자열 검색
grep("[at]",words,value=TRUE)
#ch또는 at가 포함된 문자열 검색
grep("ch|at",words,value=TRUE)
words<-c('at','bat','cat','cheap','check','cheese','chick','hat','chase','chaenomeles','chasse')
words<-c('at','bat','cat','cheap','check','cheese','chick','hat','chase','chaenomeles','chasse')
grep("chas*e",words,value=TRUE) #chase,chae,chasee
grep("chas+e",words,value=TRUE)
grep("^c",words,value=TRUE)
grep("t$",words,value=TRUE)
#at앞에 아무 문자도 없거나 h 또는 c로 시작하는 문자열을 검색
grep("^[hc]?at",words,value=TRUE)
grep("^at|(h|c)at",words,value=TRUE)
word2<-c("12 Dec", "OK", "http://", "<TITLE>Time?</TITLE>","12345", "Hi there")
grep("[[:alnum:]]",word2,value = TRUE)
grep("[[:alnum:]]",word2,value = TRUE)
grep("\\w",word2,value = TRUE)
grep("[[:alpha:]]",word2,value = TRUE)
grep("[[:digit:]]",word2,value = TRUE)
grep("\\d",word2,value = TRUE)
grep("[[:punct:]]",word2,value = TRUE)
grep("[[:space:]]",word2,value = TRUE)
grep("\\s",word2,value = TRUE)
Sys.Date()
date()
Sys.time()
class(Sys.Date()) #타입=date
class("2021-02-26") #타임=문자열
as.Date("2021-02-26") #date타입->문자열 타입
as.Date("02/26/2021",format="%m/%d/%y")  #2021-02-25이런 형식이 기본형식,기본형식이 아닐경우 format적용
d<-as.Date("2021-02-26")
format(d,format="%m/%d/%y")
d<-as.Date("2021-02-27")
d-1  #연산 가능함
d+1:10
weekdays(d+1:10)
#seq함수: 연속된 날짜 생성
s<-as.Date("2021-02-26")
e<-as.Date("2021-04-1")
seq(s,e,1)
#동일한 결과
seq(from=s,by=7,length.out=9)
seq(from=s,by="7 days",length.out=9)
seq(from=s,by="week",length.out=9)
seq(from=s,by="month",length.out=9)
seq(from=s,by="2 months",length.out=9)
seq(from=s,by="year",length.out=9)
seq(from=s,by="2 year",length.out=9)
seq(from=as.Date("2021-01-30"),by="month",length.out=5)
s<-as.Date("2021-02-26")
qrt<-seq(from=s,by="3 months",length.out=4)
qrt
months(qrt)
quarters(qrt)  #분기정보
install.packages("reprex")
product<-data.frame()
product
product<-edit(product)  #fix(product)와 같은 문장
write.csv(product,file="myproduct.csv",row.names = FALSE)
#엑셀에서 name열 복사 한 후
p<-readClipboard()
p
read.table(file="clipboard",sep="\t",header=TRUE)
#a1부터 c4까지 복사
p<-readClipboard()
p
read.table(file="clipboard",sep="\t",header=TRUE)
read.csv("product.csv")
read.csv("product-with-no-header.csv",header=FALSE)
p<-read.csv("product.csv",stringsAsFactors = TRUE)
str(p)
p<-read.csv("product.csv",as.is=TRUE)  #as.is=TRUE는 stringAsFactors=FALSE와 같음
#readtable은 다양한 구성의 자료를 읽을 수 있고 readcsv는 ,로 구분된 자료를 읽음
#read.table은 첫번째부터 데이터로 봄(헤더 설장 따로 해주어야함)
p<-read.table("product.txt",header=TRUE)
p
str(p)
read.table("product-colon.txt",sep=":",header=TRUE)
# cty 변수는 도시 연비, hwy 변수는고속도로 연비를 의미합니다.
# 변수명을 이해하기 쉬운 단어로 바꾸려고 합니다.
# mpg 데이터를 이용해서 아래 문제를 해결해 보세요.
# • Q1. ggplot2 패키지의 mpg 데이터를 사용할 수 있도록 불러온 뒤 복사본을 만드세요.
library(ggplot2)
install.packages('ggplot2')
install.packages("ggplot2")
#mpg dataset
library(ggplot2)
mpg #tibble 구조
str(mpg)
mpg$displ
# cty 변수는 도시 연비, hwy 변수는고속도로 연비를 의미합니다.
# 변수명을 이해하기 쉬운 단어로 바꾸려고 합니다.
# mpg 데이터를 이용해서 아래 문제를 해결해 보세요.
# • Q1. ggplot2 패키지의 mpg 데이터를 사용할 수 있도록 불러온 뒤 복사본을 만드세요.
library(ggplot2)
head(mpg)
mpg_dup=mpg
mpg_dup<-data.frame(mpg)
mpg_dup
# • Q2. 복사본 데이터를 이용해서 cty는 city로, hwy는 highway로 변수명을 수정하세요.
names(mpg_dup)
library(dplyr)
mpg_dup<-rename(mpg_dup,city=cty)
mpg_dup<-rename(mpg_dup,highway=gwy)
mpg_dup<-rename(mpg_dup,highway=hwy)
names(mpg_dup)
# • Q3 자동차 배기량에 따라 고속도로 연비가 다른지 알아보자
# - displ(배기량)이 4 이하인 자동차와 5 이상인 자동차 중 어떤 자동차의 hwy(연비)가 평균적으로 높은가?
under4hwy<-mean(mpg_dup[mpg_dup$displ<=4,"highway"])
under5hwy<-mean(mpg_dup[mpg_dup$displ>=5,"highway"])
max(under4hwymunder5hwy)
max(under4hwy,under5hwy)
#   • Q5. 자동차 제조 회사에 따라 도시 연비가 다른지 알아보자.
# -"audi"와 "toyota" 중 어느 manufacturer의 cty가 평균적으로 높은지 알아 보자.
str(mpg_dup)
mpg_dup$manufacturer<-as.factor(mpg_dup$manufacturer)
mpg
mpg_dup
class(mpg)
class(mpg_dup)
toyotacty<-mean(mpg_dup$city[mpg$manufacturer=='toyota'])
audicty<-mean(mpg_dup$city[mpg$manufacturer=='audi'])
toyotacty<-mean(mpg_dup$city[mpg$manufacturer=='toyota'])
c('audicty','toyotacty')
audicty<-mean(mpg_dup$city[mpg$manufacturer=='audi'])
toyotacty<-mean(mpg_dup$city[mpg$manufacturer=='toyota'])
c('audicty','toyotacty')
#   • Q5. 자동차 제조 회사에 따라 도시 연비가 다른지 알아보자.
# -"audi"와 "toyota" 중 어느 manufacturer의 cty가 평균적으로 높은지 알아 보자.
str(mpg_dup)
mpg_dup$manufacturer<-as.factor(mpg_dup$manufacturer)
audicty<-mean(mpg_dup$city[mpg$manufacturer=='audi'])
toyotacty<-mean(mpg_dup$city[mpg$manufacturer=='toyota'])
c('audicty','toyotacty')
c(audicty,toyotacty)
audicty<-mean(mpg_dup$city[mpg_dup$manufacturer=='audi'])
toyotacty<-mean(mpg_dup$city[mpg_dup$manufacturer=='toyota'])
c(audicty,toyotacty)
# • Q6. 자동차 종류에 따라 도시 연비가 다른지 알아보자.
# - class가 "suv"인 자동차와 "compact"인 자동차 중 어떤 자동차의 cty가 더 높은지 알아보자.
str(mpg_dup)
mpgclass<-unique(mpg_dup$class)
mpgclass
compactcty<-mean(mpg_dup$city[mpg_dup$class='compact'])
suvcty<-mean(mpg_dup$city[mpg_dup$class='suv'])
c(compactcty,suvcty)
compactcty<-mean(mpg_dup$city[mpg_dup$class='compact'])
suvcty<-mean(mpg_dup$city[mpg_dup$class='suv'])
c(compactcty,suvcty)
compactcty<-mean(mpg_dup$city[mpg_dup$class='compact'])
suvcty<-mean(mpg_dup$city[mpg_dup$class='suv'])
compactcty<-mean(mpg_dup$city[mpg_dup$class=='compact'])
suvcty<-mean(mpg_dup$city[mpg_dup$class=='suv'])
c(compactcty,suvcty)
# 7. ggplot2 패키지에는 미국 동북중부 437개 지역의 인구통계 정보를 담은 midwest라는
# 데이터가 포함되어있습니다. midwest 데이터를 사용해 데이터 분석 문제를 해결해보세요.
# • 문제 1. ggplot2 의 midwest 데이터를 데이터 프레임 형태로 불러와서 데이터의 특성을 파악하세요.
midwest<-as.data.frame(midwest)
head(midwest)
str(midwest)
# • 문제 2. poptotal(전체 인구)을 total 로, popasian(아시아 인구)을 asian 으로 변수명을 수정하세요.
midwest<-rename(midwest,total=poptotal)
midwest<-rename(midwest,asian=popasian)
head(midwest)
# • 문제 3. 아시아 인구 백분율 전체 평균을 구하고, 평균을 초과하면 "large", 그 외에는 "small"을 부여하는
# 파생변수를 만들어 보세요
prop<-midwest$asian/midwest$total
meanprop<-mean(prop)
prop>meanprop
midwest$size<-c('large')
midwest
midwest$size[prop<=meanprop]<-'small'
midwest
#
# 8. 햄릿 데이터 파일을 읽은 후 다음 작업을 진행하시오.
haml<-readline('data/Hamlet.txt')
haml
#
# 8. 햄릿 데이터 파일을 읽은 후 다음 작업을 진행하시오.
haml<-readline('data/Hamlet.txt')
#
# 8. 햄릿 데이터 파일을 읽은 후 다음 작업을 진행하시오.
haml<-readlines('data/Hamlet.txt')
haml
#
# 8. 햄릿 데이터 파일을 읽은 후 다음 작업을 진행하시오.
haml<-readlines('Home/rwork/Hamlet.txt')
haml
#
# 8. 햄릿 데이터 파일을 읽은 후 다음 작업을 진행하시오.
haml<-readLines('Home/rwork/Hamlet.txt')
#
# 8. 햄릿 데이터 파일을 읽은 후 다음 작업을 진행하시오.
haml<-readLines('Hamlet.txt')
haml
# • 문제 1. ******로 시작하고 ******로 끝나는 문자열 추출
grep('^[*]{6}.+[*]{6}$',haml,value=T)
# • 문제 2. 대문자로 시작되는 단어들만 추출 -> 단어별 빈도수 출력
haml1<-unlist(strsplit(haml,' '))
str(haml1)
# • 문제 2. 대문자로 시작되는 단어들만 추출 -> 단어별 빈도수 출력
class(haml1)
# • 문제 2. 대문자로 시작되는 단어들만 추출 -> 단어별 빈도수 출력
class(haml)
haml1<-strsplit(haml,' ')
str(haml1)
class(haml1)
haml1<-unlist(strsplit(haml,' '))
uppers<-grep('[^[:alpha:]]',haml1,value=T)
upeers<-gsub('[^[:alpha:]]',replacement='',uppers)
table(uppers)
# • 문제 3. 대괄호([ 또는 ])로 묶여있는 문자열 출력
haml
charr<-grep("[[].*[]]",haml,value=T)
gsub('.*[[]|[]].*',replacement='',charr)
# • 문제 4. 모든 단어를 소문자로 변환 -> 가장 빈도수가 높은 단어 50개 출력
words.lower<-tolower(words)
words.lower.df<-data.frame(table(factor(words.lower)))
words.lower.df
head(words.lower.df[order(words.lower.df$Freq,decreasing = T),],50)
# • 문제 4. 모든 단어를 소문자로 변환 -> 가장 빈도수가 높은 단어 50개 출력
words.lower<-tolower(words)
words.lower.df<-data.frame(table(factor(words.lower)))
words.lower.df
head(words.lower.df[order(words.lower.df$Freq,decreasing = T),],50)
# • 문제 4. 모든 단어를 소문자로 변환 -> 가장 빈도수가 높은 단어 50개 출력
lowers<-tolower(haml1)
lowers<-gsub('[^[:alpha:]]',replacement = '',lowers)
lowers
# • 문제 4. 모든 단어를 소문자로 변환 -> 가장 빈도수가 높은 단어 50개 출력
lowers<-tolower(haml1)
lowers
lowers<-gsub('[^[:alpha:]]',replacement = '',lowers)
lowers
lowers<-lowers[lowers!=""]
lowers
tabsor<-table(lowers)
tabsor
head(tabsor)
df<-as.data.frame(tabsor)
df
head(df[order(df$Freq,decreasing=T),],50)
# • 문제 5. Ham. ->Hamlet. 으로 치환
repla<-gsub('Ham[.]',replacement = 'Hamlet.',haml1)
grep('Ham[.]',repla,value=T)
# • 문제 5. Ham. ->Hamlet. 으로 치환
repla<-gsub('Ham[.]',replacement = 'Hamlet.',haml1)
grep('Ham[.]',repla,value=T)
grep('Hamlet[.]',repla,value=T)
# • 문제 6. Scene 으로 시작되는 문자열 출력
grep('^(Scene)',haml,value=T)
# 9. 2021년 2월 27일부터 7일간 월, 일, 요일을 출력
# "토-0227" "일-0228" ...
today<-Sys.Date()
date7<-seq(today+1,by=1,length.out=7)
date7
date7<-seq(today+1,by=1,length.out=7)
date<-seq(today,by=1,length.out=7)
date7
date
weeks<-weekdays(date7)
days<-format(date7,format='%d일')
days
date.frame(date7,weeks,months,days)
date.frame(date7,weeks,Months,days)
# 9. 2021년 2월 27일부터 7일간 월, 일, 요일을 출력
# "토-0227" "일-0228" ...
today<-Sys.Date()
date7<-seq(today+1,by=1,length.out=7)
weeks<-weekdays(date7)
Months<-months(date7)
days<-format(date7,format='%d일')
date.frame(date7,weeks,Months,days)
data.frame(date7,weeks,Months,days)
#or
today <- Sys.Date()
format(today+1:7, format='%a-%m%d')
d <- as.Date('2021-02-27')
format(d+0:6, format='%a-%m%d')
